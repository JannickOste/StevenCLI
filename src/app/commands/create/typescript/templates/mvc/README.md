# Typescript MVC

## Overview

This project is a template generated by a CLI tool to build a scalable and maintainable TypeScript Node.js application using InversifyJS for dependency injection and TypeORM for database interaction. It includes user management functionality as an example to demonstrate the model, repository, service, and controller layers.

## Table of Contents

- [Installation](#installation)
- [Configuration](#configuration)
- [Running the Application](#running-the-application)
- [Explanation of Layers](#explanation-of-layers)
  - [Model](#model)
  - [Repository](#repository)
  - [Service](#service)
  - [Controller](#controller)
- [Dependency Injection Setup](#dependency-injection-setup)
- [Creating Your Own Feature](#creating-your-own-feature)

## Installation

Install the adapter package for your database. For example, if you are using MySQL:
```bash
npm install mysql2
```

## Configuration

Create a `.env` file in the root directory with the following content, adjusting the values to match your database configuration:

```
DATABASE_TYPE=postgres
DATABASE_HOST=localhost
DATABASE_PORT=5432
DATABASE_USER=yourusername
DATABASE_PASS=yourpassword
DATABASE_DB=yourdatabase
DATABASE_SYNC=true
DATABASE_LOG=true
```

## Running the Application

To start the application, run:
```bash
npm start
```

## Explanation of Layers

### Model

The model represents the data structure of your application and is mapped to a database table. TypeORM is used to define entities.

Example User Model:
```typescript
import { Entity, PrimaryGeneratedColumn, Column } from "typeorm";

@Entity()
export class User {
    @PrimaryGeneratedColumn()
    id!: number;

    @Column()
    firstName!: string;

    @Column()
    lastName!: string;

    @Column()
    age!: number;
}
```

### Repository

The repository handles data access logic, providing an abstraction over the database operations. It uses TypeORM's repository pattern to interact with the database.

Example UserRepository:
```typescript
import { Repository } from "typeorm";
import { inject, injectable } from "inversify";
import TYPES from "../../../TYPES";
import IDatabase from "../../../core/domain/database/IDatabase";
import { User } from "../../domain/models/User";

@injectable()
export default class UserRepository {
    private userRepository: Repository<User>;

    constructor(
        @inject(TYPES.Core.Database.IDatabase) private readonly database: IDatabase
    ) {
        this.userRepository = this.database.manager.getRepository(User);
    }

    async list(): Promise<User[]> {
        return this.userRepository.find();
    }
}
```

### Service

The service layer contains business logic and interacts with repositories. It provides a clean API for the controllers to perform operations.

Example UserService:
```typescript
import { inject, injectable } from "inversify";
import APP_TYPES from "../../APP_TYPES";
import UserRepository from "../repositories/UserRepository";
import { User } from "../../domain/models/User";

@injectable()
export default class UserService {
    constructor(
        @inject(APP_TYPES.repositories.IUserRepository) private readonly repository: UserRepository
    ) {}

    list(): Promise<User[]> {
        return this.repository.list();
    }
}
```

### Controller

The controller handles HTTP requests, invokes the appropriate service methods, and returns responses. It uses the Inversify Express Utils library to define routes and dependency injection.

Example UserController:
```typescript
import { controller, httpGet, interfaces, HttpResponseMessage, JsonContent } from "inversify-express-utils";
import { inject } from "inversify/lib/annotation/inject";
import APP_TYPES from "../../APP_TYPES";
import UserService from "../../infrastructure/services/UserService";

@controller("/user")
export default class UserController implements interfaces.Controller {
    constructor(
        @inject(APP_TYPES.services.IUserService) private userService: UserService
    ) {}

    @httpGet("/")
    private async list(): Promise<HttpResponseMessage> {
        const response = new HttpResponseMessage(200);
        response.content = new JsonContent(await this.userService.list());

        return response;
    }
}
```
## Dependency Injection Setup

Dependency injection is configured using InversifyJS. The setup involves registering all necessary dependencies in a container and ensuring they are initialized properly.

### Startup Files

The startup classes handle the registration and configuration of services. This is where you register and configure all your dependencies. Let's take the `CoreStartup` as an example.

```typescript
import { Container, inject, injectable } from "inversify";
import TYPES from "../../TYPES";
import IDatabase from "../domain/database/IDatabase";
import Database from "./database/Database";
import ExpressServer, { IExpressServer } from "./http/ExpressServer";
import IStartup from "../domain/IStartup";
import "reflect-metadata";

@injectable()
export default class CoreStartup implements IStartup {
    constructor(
        @inject(TYPES.container) private readonly container: Container
    ) {}

    async registerServices(): Promise<void> {
        // Bind your dependencies to the container, this can be accessed using DI with the TYPES.container symbol.
        this.container.bind<IDatabase>(TYPES.Core.Database.IDatabase).to(Database).inSingletonScope();
        this.container.bind<IExpressServer>(TYPES.Core.Http.IExpressServer).to(ExpressServer).inSingletonScope();
    }

    async configureServices(): Promise<void> {
        // Here is where your initialization/configuration logic should go. This function is run after all startup files have registered their dependencies.
        await this.container.get<IDatabase>(TYPES.Core.Database.IDatabase).initialize();

        const express = this.container.get<IExpressServer>(TYPES.Core.Http.IExpressServer);

        await (await express.initialize()).listen(
            3000,
            () => { console.log("API started on port 3000"); }
        );
    }
}
```

If you wish to add a new startup file, you can do so using the `ApplicationBuilder` by passing the Startup class to `setStartup`.

```typescript
(async () => {
    const application: IApplication = await (new ApplicationBuilder()
                            .setStartUp(AppStartup)
                            .build(Application));
    
    application.main();
})();
```

Alternatively, you can assign one in the dependency container.

```typescript
import { Container, injectable } from "inversify";
import TYPES from "../../TYPES";
import CoreStartup from "./CoreStartup";
import IStartup from "../domain/IStartup";
import "reflect-metadata";

@injectable()
class DependencyContainer extends Container {
    constructor() {
        super();
        this.registerServices();
    }

    registerServices() {
        this.bind<Container>(TYPES.container).toConstantValue(this);
        this.bind<IStartup>(TYPES.Core.IStartup).to(CoreStartup);
        // Add new startup classes here
    }
}
```

In this setup, `DependencyContainer` manages the registration of all services and startup classes, ensuring they are available for dependency injection throughout the application.

## Creating Your Own Feature

To create a new feature, follow these steps:

1. **Define the Model:**
   Create a new model class with TypeORM decorators to define the entity structure.

2. **Create the Repository:**
   Implement a repository class that extends TypeORM's `Repository` and contains methods for data access.

3. **Implement the Service:**
   Create a service class that includes business logic and interacts with the repository.

4. **Set Up the Controller:**
   Define a controller class that handles HTTP requests and uses the service methods.

5. **Register Dependencies:**
   Ensure that your new classes are registered in the dependency injection container using the startup files.
